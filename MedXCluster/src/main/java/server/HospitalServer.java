package server;

import common.*;
import org.apache.activemq.ActiveMQConnectionFactory;
import org.omg.CORBA.ORB;
import org.omg.PortableServer.POA;
import org.omg.PortableServer.POAHelper;

import java.rmi.server.UnicastRemoteObject;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.concurrent.LinkedBlockingQueue;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import javax.jms.*;
import java.io.File;
import java.io.PrintWriter;

public class HospitalServer extends UnicastRemoteObject implements ComputeService {

    // ==========================================
    // 1. DATA STRUCTURES
    // ==========================================
    // Queue to hold the unprocessed image strips
    private LinkedBlockingQueue<ImageChunk> tasks = new LinkedBlockingQueue<>();

    // Image details
    private int totalChunks = 40; // How many strips to cut the image into

    // ==========================================
    // 2. CONSTRUCTOR & IMAGE LOADING
    // ==========================================
    public HospitalServer() throws Exception {
        super();
        // Make sure this file exists in your project folder!
        loadImageAndSplit("src/main/resources/hand-xray.jpg");
    }

    private void loadImageAndSplit(String path) throws Exception {
        File imgFile = new File(path);
        if (!imgFile.exists()) {
            System.err.println("ERROR: Image not found at " + imgFile.getAbsolutePath());
            return;
        }

        BufferedImage original = ImageIO.read(imgFile);
        int w = original.getWidth();
        int h = original.getHeight();

        System.out.println("Loaded Image: " + w + "x" + h);

        int chunkHeight = h / totalChunks;

        for (int i = 0; i < totalChunks; i++) {
            int y = i * chunkHeight;
            // Handle last chunk height (in case height isn't perfectly divisible)
            int currentH = (i == totalChunks - 1) ? (h - y) : chunkHeight;

            // Extract pixels
            int[] pixels = original.getRGB(0, y, w, currentH, null, 0, w);

            // Add to queue
            tasks.add(new ImageChunk(i, 0, y, w, currentH, pixels));
        }
        System.out.println("Image split into " + tasks.size() + " tasks.");
    }

    // ==========================================
    // 3. RMI IMPLEMENTATION (Worker Logic)
    // ==========================================
    @Override
    public ImageChunk getTask() {
        // Worker calls this to get work. Returns null if queue is empty.
        return tasks.poll();
    }

    @Override
    public void submitResult(ProcessedChunk result) {
        System.out.println("Received processed chunk ID: " + result.id);
        // Once received, broadcast to Doctor via JMS
        sendJmsUpdate(result);
    }

    // ==========================================
    // 4. JMS IMPLEMENTATION (Doctor Logic)
    // ==========================================
    private void sendJmsUpdate(ProcessedChunk result) {
        try {
            ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
            // CRITICAL: Allow Objects to be serialized
            ((ActiveMQConnectionFactory) factory).setTrustAllPackages(true);

            Connection connection = factory.createConnection();
            connection.start();

            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
            Topic topic = session.createTopic("TeleRadiology");

            MessageProducer producer = session.createProducer(topic);
            ObjectMessage msg = session.createObjectMessage(result);

            producer.send(msg); // Send to Dashboard

            session.close();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // ==========================================
    // 5. CORBA INNER CLASS (Admin Logic)
    // ==========================================
    // This class implements the Interface generated by 'idlj'
    static class MonitorImpl extends CorbaModule.MonitorPOA {
        private final HospitalServer server;

        public MonitorImpl(HospitalServer server) {
            this.server = server;
        }

        @Override
        public String getStatus() {
            int remaining = server.tasks.size();
            return "System Online. Pending Tasks: " + remaining;
        }
    }

    // ==========================================
    // 6. MAIN METHOD (Entry Point)
    // ==========================================
    public static void main(String[] args) {
        try {
            // --- STEP A: Initialize CORBA ---
            ORB orb = ORB.init(args, null);
            POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
            rootpoa.the_POAManager().activate();

            // --- STEP B: Create Server Instance ---
            HospitalServer hs = new HospitalServer();

            // --- STEP C: Link CORBA Monitor ---
            MonitorImpl monitor = new MonitorImpl(hs);
            org.omg.CORBA.Object ref = rootpoa.servant_to_reference(monitor);

            // IMPORTANT: Write the IOR (Connection String) to a file so Client can find it
            String ior = orb.object_to_string(ref);
            PrintWriter out = new PrintWriter("server.ior");
            out.println(ior);
            out.close();
            System.out.println("CORBA Monitor ready. IOR written to 'server.ior'.");

            // --- STEP D: Register RMI ---
            Registry registry = LocateRegistry.createRegistry(1099);
            registry.rebind("ComputeService", hs);
            System.out.println("RMI Service Ready on port 1099...");

            // --- STEP E: Run CORBA in Background Thread ---
            // If we don't do this, CORBA won't listen for requests!
            new Thread(() -> {
                try {
                    orb.run();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}